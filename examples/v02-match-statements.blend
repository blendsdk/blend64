// Blend65 v0.2 Example: Enhanced Match Statements with Default Cases
// Demonstrates pattern matching for game logic

module Match.Examples
import setSpritePosition from c64.sprites
import playSound from c64.sound

// Enums for match examples
enum GameState
  MENU, PLAYING, PAUSED, GAME_OVER
end enum

enum PlayerAction
  IDLE, WALK, RUN, JUMP, SHOOT, CROUCH
end enum

enum EnemyType
  GOOMBA = 1,
  KOOPA = 2,
  PIRANHA_PLANT = 3,
  BOWSER = 10
end enum

enum WeaponType
  FIST, SWORD, BOW, MAGIC_STAFF
end enum

// Global game state
var gameState: GameState = GameState.MENU
var playerAction: PlayerAction = PlayerAction.IDLE

// Example 1: Basic match with default case
function handleGameState(): void
  match gameState
    case GameState.MENU:
      showMenu()
      handleMenuInput()
    case GameState.PLAYING:
      updateGame()
      renderGame()
    case GameState.PAUSED:
      showPauseScreen()
    default:
      // Handle any unexpected state
      gameState = GameState.MENU
  end match
end function

// Example 2: Match with complex case logic
function handlePlayerAction(action: PlayerAction): void
  match action
    case PlayerAction.IDLE:
      setPlayerSprite(0)  // Idle animation frame
      playerSpeed = 0
    case PlayerAction.WALK:
      setPlayerSprite(1)  // Walking animation
      playerSpeed = 1
      playSound(FOOTSTEP)
    case PlayerAction.RUN:
      setPlayerSprite(2)  // Running animation
      playerSpeed = 3
      playSound(FOOTSTEP)
    case PlayerAction.JUMP:
      setPlayerSprite(3)  // Jump animation
      playerY = playerY - jumpHeight
      playSound(JUMP_SOUND)
    case PlayerAction.SHOOT:
      setPlayerSprite(4)  // Shooting animation
      fireBullet()
      playSound(LASER)
    case PlayerAction.CROUCH:
      setPlayerSprite(5)  // Crouching animation
      playerSpeed = 0
      playerHeight = 8   // Reduced collision box
    default:
      // Unknown action, set to idle
      action = PlayerAction.IDLE
      playerSpeed = 0
  end match
end function

// Example 3: Match with numeric literals
function handleInput(keyCode: byte): void
  match keyCode
    case 32:  // Space key
      if gameState == GameState.PLAYING then
        playerAction = PlayerAction.SHOOT
      end if
    case 87:  // W key
      playerAction = PlayerAction.JUMP
    case 65:  // A key
      playerDirection = Direction.LEFT
      playerAction = PlayerAction.WALK
    case 68:  // D key
      playerDirection = Direction.RIGHT
      playerAction = PlayerAction.WALK
    case 83:  // S key
      playerAction = PlayerAction.CROUCH
    default:
      // Unknown key, stop movement
      playerAction = PlayerAction.IDLE
  end match
end function

// Example 4: Match for AI behavior
function processEnemyAI(enemyType: EnemyType, playerId: byte): void
  match enemyType
    case EnemyType.GOOMBA:
      // Simple walking enemy
      if playerX < enemyX then
        enemyDirection = Direction.LEFT
      else
        enemyDirection = Direction.RIGHT
      end if
      moveEnemy(1)  // Slow speed
    case EnemyType.KOOPA:
      // Shell enemy with special behavior
      if enemyShellMode then
        spinShell()
      else
        moveTowardsPlayer()
      end if
    case EnemyType.PIRANHA_PLANT:
      // Stationary enemy that attacks
      if distanceToPlayer() < 16 then
        attackPlayer()
      end if
    case EnemyType.BOWSER:
      // Boss enemy with complex AI
      executeBossAI()
      if bossHealth < 50 then
        enterRageMode()
      end if
    default:
      // Unknown enemy type, make it harmless
      enemyHealth = 0
  end match
end function

// Example 5: Match for weapon damage calculation
function calculateDamage(weapon: WeaponType, enemyType: EnemyType): byte
  var baseDamage: byte = 0

  // Calculate base damage based on weapon
  match weapon
    case WeaponType.FIST:
      baseDamage = 1
    case WeaponType.SWORD:
      baseDamage = 5
    case WeaponType.BOW:
      baseDamage = 3
    case WeaponType.MAGIC_STAFF:
      baseDamage = 8
    default:
      baseDamage = 1  // Default to minimal damage
  end match

  // Apply enemy-specific modifiers
  match enemyType
    case EnemyType.GOOMBA:
      return baseDamage
    case EnemyType.KOOPA:
      return baseDamage + 1  // Slightly tougher
    case EnemyType.PIRANHA_PLANT:
      return baseDamage + 2  // Tough plant
    case EnemyType.BOWSER:
      return baseDamage / 2  // Boss has armor
    default:
      return baseDamage
  end match
end function

// Example 6: Nested match statements for complex logic
function handleCombatSystem(): void
  match gameState
    case GameState.PLAYING:
      match playerAction
        case PlayerAction.SHOOT:
          for enemyId = 0 to maxEnemies - 1
            if enemies[enemyId].active then
              var damage: byte = calculateDamage(currentWeapon, enemies[enemyId].enemyType)
              enemies[enemyId].health = enemies[enemyId].health - damage
            end if
          next enemyId
        case PlayerAction.JUMP:
          // Handle jump combat (stomp enemies)
          for enemyId = 0 to maxEnemies - 1
            if isAboveEnemy(enemyId) then
              enemies[enemyId].health = 0
              playerAction = PlayerAction.IDLE
            end if
          next enemyId
        default:
          // No combat action
      end match
    default:
      // Not in playing state, no combat
  end match
end function

export function gameLoop(): void
  while true
    handleGameState()
    handleCombatSystem()

    if gameState == GameState.GAME_OVER then
      break
    end if
  end while
end function
