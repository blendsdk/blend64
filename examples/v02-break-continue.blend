// Blend65 v0.2 Example: Break and Continue Statements
// Demonstrates loop control with break and continue

module LoopControl.Examples
import setSpritePosition from c64.sprites
import readJoystick from c64.input

zp var playerX: byte = 20
zp var playerY: byte = 12
ram var enemies: byte[32]
ram var bullets: byte[16]

// Example 1: Using break to exit early from enemy search
function findNearestEnemy(): byte
  for i = 0 to 31
    if enemies[i] == 0 then
      continue  // Skip inactive enemies
    end if

    if isNearPlayer(i) then
      return i  // Found nearest enemy
    end if
  next i

  return 255  // No enemy found
end function

// Example 2: Using continue to skip processing
function updateBullets(): void
  for bulletId = 0 to 15
    if bullets[bulletId] == 0 then
      continue  // Skip inactive bullets
    end if

    // Move bullet
    bullets[bulletId] = bullets[bulletId] + 1

    // Check if bullet hit enemy
    for enemyId = 0 to 31
      if enemies[enemyId] == 0 then
        continue  // Skip inactive enemy
      end if

      if collision(bulletId, enemyId) then
        bullets[bulletId] = 0   // Deactivate bullet
        enemies[enemyId] = 0    // Destroy enemy
        break  // Exit enemy loop, bullet is gone
      end if
    next enemyId
  next bulletId
end function

// Example 3: Complex nested loop control
function processPlayerInput(): void
  while true
    var input: byte = readJoystick()

    if input == 0 then
      continue  // No input, continue game loop
    end if

    // Process movement input
    for direction = 1 to 4
      if input != direction then
        continue  // Not this direction
      end if

      // Check collision before moving
      for obstacleId = 0 to maxObstacles - 1
        if wouldCollide(direction, obstacleId) then
          break  // Can't move this direction, exit obstacle check
        end if
      next obstacleId

      // Safe to move
      movePlayer(direction)
      break  // Exit direction loop
    next direction
  end while
end function

// Example 4: Search algorithms with early termination
function findPath(startX: byte, startY: byte, targetX: byte, targetY: byte): boolean
  for pathLength = 1 to 100
    for x = 0 to 39
      for y = 0 to 24
        if isWall(x, y) then
          continue  // Skip walls
        end if

        if x == targetX and y == targetY then
          return true  // Path found!
        end if

        if pathLength > 50 then
          break  // Too long, try different approach
        end if
      next y
    next x

    if pathLength > 75 then
      break  // Give up search
    end if
  next pathLength

  return false  // No path found
end function

export function main(): void
  // Game loop using break/continue
  while true
    processPlayerInput()
    updateBullets()

    var nearestEnemy: byte = findNearestEnemy()
    if nearestEnemy != 255 then
      // AI logic here
    end if

    // Check game over condition
    if playerHealth <= 0 then
      break  // Exit game loop
    end if
  end while
end function
