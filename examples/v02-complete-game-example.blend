// Blend65 v0.2 Complete Game Example
// Demonstrates all v0.2 features (break/continue, enums, match statements) in a real game

module SpaceInvaders.Main
import setSpritePosition from c64.sprites
import setSpriteColor from c64.sprites
import readJoystick from c64.input
import playNote from c64.sound

// Game state management with enums
enum GameState
  TITLE_SCREEN = 0,
  PLAYING = 1,
  PAUSED = 2,
  GAME_OVER = 3,
  VICTORY = 4
end enum

enum Direction
  NONE, LEFT, RIGHT, UP, DOWN
end enum

enum EntityType
  PLAYER = 1,
  BULLET = 2,
  ENEMY = 3,
  POWERUP = 4,
  EXPLOSION = 5
end enum

enum SoundEffect
  SHOOT = 100,
  EXPLODE = 150,
  POWERUP = 200,
  DEATH = 255
end enum

export enum DifficultyLevel
  EASY = 1,
  NORMAL = 2,
  HARD = 3,
  EXPERT = 4
end enum

// Game state variables
var gameState: GameState = GameState.TITLE_SCREEN
var difficulty: DifficultyLevel = DifficultyLevel.NORMAL
var playerDirection: Direction = Direction.NONE

// Game entities using storage classes
zp var playerX: byte = 20
zp var playerY: byte = 20
zp var score: word = 0
ram var bullets: byte[32]
ram var enemies: byte[64]
ram var explosions: byte[16]

// Game loop with all v0.2 features
export function main(): void
  while true
    // Main game state machine using match with default case
    match gameState
      case GameState.TITLE_SCREEN:
        showTitleScreen()
        if startButtonPressed() then
          gameState = GameState.PLAYING
          initializeGame()
        end if
      case GameState.PLAYING:
        handleGameplay()
      case GameState.PAUSED:
        showPauseScreen()
        if resumeButtonPressed() then
          gameState = GameState.PLAYING
        end if
      case GameState.GAME_OVER:
        showGameOverScreen()
        if restartButtonPressed() then
          gameState = GameState.TITLE_SCREEN
        end if
      case GameState.VICTORY:
        showVictoryScreen()
        if continueButtonPressed() then
          gameState = GameState.TITLE_SCREEN
        end if
      default:
        // Error recovery - return to title
        gameState = GameState.TITLE_SCREEN
    end match

    // Exit main loop if needed
    if shouldExitGame() then
      break
    end if
  end while
end function

// Complex gameplay logic using all v0.2 features
function handleGameplay(): void
  processPlayerInput()
  updateBullets()
  updateEnemies()
  checkCollisions()
  updateExplosions()

  // Check win/lose conditions
  if playerHealth <= 0 then
    gameState = GameState.GAME_OVER
  end if

  if allEnemiesDestroyed() then
    gameState = GameState.VICTORY
  end if
end function

// Player input processing with match statements
function processPlayerInput(): void
  var joystick: byte = readJoystick()
  var firePressed: boolean = fireButtonPressed()

  // Direction processing with match
  match joystick
    case 1:  // Up
      playerDirection = Direction.UP
      if playerY > 0 then
        playerY = playerY - 1
      end if
    case 2:  // Down
      playerDirection = Direction.DOWN
      if playerY < 24 then
        playerY = playerY + 1
      end if
    case 3:  // Left
      playerDirection = Direction.LEFT
      if playerX > 0 then
        playerX = playerX - 1
      end if
    case 4:  // Right
      playerDirection = Direction.RIGHT
      if playerX < 39 then
        playerX = playerX + 1
      end if
    default:
      playerDirection = Direction.NONE
  end match

  // Shooting logic
  if firePressed then
    fireBullet()
  end if

  setSpritePosition(0, playerX, playerY)
end function

// Bullet system with break/continue for optimization
function updateBullets(): void
  for bulletId = 0 to 31
    // Skip inactive bullets
    if bullets[bulletId] == 0 then
      continue
    end if

    // Move bullet up
    bullets[bulletId] = bullets[bulletId] - 1

    // Remove bullets that go off screen
    if bullets[bulletId] < 0 then
      bullets[bulletId] = 0
      continue
    end if

    // Check enemy collisions
    for enemyId = 0 to 63
      if enemies[enemyId] == 0 then
        continue  // Skip inactive enemies
      end if

      if bulletHitsEnemy(bulletId, enemyId) then
        // Bullet hit enemy
        enemies[enemyId] = 0        // Destroy enemy
        bullets[bulletId] = 0       // Destroy bullet
        score = score + 10          // Add score
        createExplosion(enemyId)    // Visual effect
        playNote(SoundEffect.EXPLODE)
        break  // Exit enemy loop, bullet is gone
      end if
    next enemyId
  next bulletId
end function

// Enemy AI with match-based behavior
function updateEnemies(): void
  for enemyId = 0 to 63
    if enemies[enemyId] == 0 then
      continue  // Skip inactive enemies
    end if

    var enemyType: EntityType = getEnemyType(enemyId)

    // AI behavior based on enemy type
    match enemyType
      case EntityType.ENEMY:
        // Basic enemy movement
        moveEnemyDown(enemyId)

        // Random shooting based on difficulty
        match difficulty
          case DifficultyLevel.EASY:
            if random() < 10 then
              enemyShoot(enemyId)
            end if
          case DifficultyLevel.NORMAL:
            if random() < 20 then
              enemyShoot(enemyId)
            end if
          case DifficultyLevel.HARD:
            if random() < 30 then
              enemyShoot(enemyId)
            end if
          case DifficultyLevel.EXPERT:
            if random() < 50 then
              enemyShoot(enemyId)
            end if
          default:
            // Default difficulty
            if random() < 15 then
              enemyShoot(enemyId)
            end if
        end match
      default:
        // Unknown enemy type, make it passive
        moveEnemyDown(enemyId)
    end match

    // Remove enemies that reach bottom
    if getEnemyY(enemyId) > 24 then
      enemies[enemyId] = 0
      continue
    end if
  next enemyId
end function

// Collision detection with early termination
function checkCollisions(): void
  // Check player-enemy collisions
  for enemyId = 0 to 63
    if enemies[enemyId] == 0 then
      continue  // Skip inactive enemies
    end if

    if playerCollidesWithEnemy(enemyId) then
      playerHealth = playerHealth - 1
      enemies[enemyId] = 0  // Destroy enemy
      createExplosion(enemyId)
      playNote(SoundEffect.DEATH)

      if playerHealth <= 0 then
        break  // Player is dead, no need to check more
      end if
    end if
  next enemyId

  // Check powerup collection
  for powerupId = 0 to maxPowerups - 1
    if powerups[powerupId] == 0 then
      continue  // Skip inactive powerups
    end if

    if playerCollectsItem(powerupId) then
      var powerupType: byte = getPowerupType(powerupId)

      match powerupType
        case 1:  // Health powerup
          playerHealth = playerHealth + 10
          if playerHealth > 100 then
            playerHealth = 100
          end if
        case 2:  // Speed powerup
          playerSpeed = playerSpeed + 1
        case 3:  // Weapon powerup
          playerWeapon = playerWeapon + 1
        default:
          // Unknown powerup, give points
          score = score + 50
      end match

      powerups[powerupId] = 0  // Remove powerup
      playNote(SoundEffect.POWERUP)
      break  // Only collect one powerup per frame
    end if
  next powerupId
end function

// Explosion animation system
function updateExplosions(): void
  for explosionId = 0 to 15
    if explosions[explosionId] == 0 then
      continue  // Skip inactive explosions
    end if

    var frame: byte = getExplosionFrame(explosionId)

    match frame
      case 1:
        setExplosionSprite(explosionId, EXPLOSION_FRAME_1)
      case 2:
        setExplosionSprite(explosionId, EXPLOSION_FRAME_2)
      case 3:
        setExplosionSprite(explosionId, EXPLOSION_FRAME_3)
      case 4:
        setExplosionSprite(explosionId, EXPLOSION_FRAME_4)
      default:
        // Animation complete
        explosions[explosionId] = 0
        continue
    end match

    // Advance animation
    explosions[explosionId] = explosions[explosionId] + 1
  next explosionId
end function

// Difficulty-based game tuning
function adjustGameDifficulty(): void
  match difficulty
    case DifficultyLevel.EASY:
      enemySpeed = 1
      enemyShootChance = 5
      playerStartingHealth = 100
    case DifficultyLevel.NORMAL:
      enemySpeed = 2
      enemyShootChance = 10
      playerStartingHealth = 75
    case DifficultyLevel.HARD:
      enemySpeed = 3
      enemyShootChance = 20
      playerStartingHealth = 50
    case DifficultyLevel.EXPERT:
      enemySpeed = 4
      enemyShootChance = 30
      playerStartingHealth = 25
    default:
      // Fallback to normal difficulty
      difficulty = DifficultyLevel.NORMAL
      adjustGameDifficulty()  // Recursive call with corrected difficulty
  end match
end function

// Complex nested control flow using all v0.2 features
function complexGameLogic(): void
  match gameState
    case GameState.PLAYING:
      // Process all active entities
      for entityId = 0 to maxEntities - 1
        if entities[entityId].active == false then
          continue  // Skip inactive entities
        end if

        var entityType: EntityType = entities[entityId].entityType

        match entityType
          case EntityType.PLAYER:
            // Player update logic
            for inputFrame = 0 to inputBufferSize - 1
              var input: byte = inputBuffer[inputFrame]
              if input == 0 then
                continue  // Skip empty input
              end if

              processInputFrame(input)

              if criticalError then
                break  // Exit input processing
              end if
            next inputFrame
          case EntityType.BULLET:
            // Bullet physics
            updateBulletPhysics(entityId)
            if bulletOffScreen(entityId) then
              entities[entityId].active = false
              continue  // Next entity
            end if
          case EntityType.ENEMY:
            // Enemy AI with nested loops
            while entities[entityId].aiThinking
              var decision: byte = makeAIDecision(entityId)

              match decision
                case 1:  // Attack
                  if canAttack(entityId) then
                    executeAttack(entityId)
                    break  // Exit AI thinking
                  end if
                case 2:  // Move
                  if canMove(entityId) then
                    executeMove(entityId)
                    break  // Exit AI thinking
                  end if
                case 3:  // Wait
                  break  // Exit AI thinking
                default:
                  // Invalid decision, try again
                  continue
              end match
            end while
          default:
            // Unknown entity type, deactivate
            entities[entityId].active = false
        end match
      next entityId
    default:
      // Not in playing state
  end match
end function

// Initialization function
function initializeGame(): void
  adjustGameDifficulty()
  playerHealth = playerStartingHealth
  score = 0

  // Clear all game entities
  for i = 0 to 31
    bullets[i] = 0
  next i

  for i = 0 to 63
    enemies[i] = 0
  next i

  for i = 0 to 15
    explosions[i] = 0
  next i
end function
